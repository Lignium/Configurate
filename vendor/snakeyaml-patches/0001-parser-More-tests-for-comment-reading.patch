From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: zml <zml@stellardrift.ca>
Date: Fri, 11 Jun 2021 15:53:37 -0700
Subject: [PATCH] parser: More tests for comment reading


diff --git a/src/main/java/org/yaml/snakeyaml/parser/ParserImpl.java b/src/main/java/org/yaml/snakeyaml/parser/ParserImpl.java
index d5b16d1edf6e0afa85f50b308cf31000c1bd2c12..a3798b4faf3bf6746654d724d437633624f11bbb 100644
--- a/src/main/java/org/yaml/snakeyaml/parser/ParserImpl.java
+++ b/src/main/java/org/yaml/snakeyaml/parser/ParserImpl.java
@@ -735,20 +735,24 @@ public class ParserImpl implements Parser {
         public Event produce() {
             Token token = scanner.getToken();
             marks.push(token.getStartMark());
+            if (scanner.checkToken(Token.ID.Comment)) {
+                state = new ParseFlowSequenceEntry(true);
+                return produceCommentEvent((CommentToken) scanner.getToken());
+            }
             return new ParseFlowSequenceEntry(true).produce();
         }
     }
 
     private class ParseFlowSequenceEntry implements Production {
-        private boolean first = false;
+        private boolean entryTokenSeen = false;
 
-        public ParseFlowSequenceEntry(boolean first) {
-            this.first = first;
+        public ParseFlowSequenceEntry(boolean entryTokenSeen) {
+            this.entryTokenSeen = entryTokenSeen;
         }
 
         public Event produce() {
             if (!scanner.checkToken(Token.ID.FlowSequenceEnd)) {
-                if (!first) {
+                if (!entryTokenSeen) {
                     if (scanner.checkToken(Token.ID.FlowEntry)) {
                         scanner.getToken();
                     } else {
@@ -764,6 +768,9 @@ public class ParserImpl implements Parser {
                             token.getEndMark(), DumperOptions.FlowStyle.FLOW);
                     state = new ParseFlowSequenceEntryMappingKey();
                     return event;
+                } else if (scanner.checkToken(Token.ID.Comment)) {
+                    state = new ParseFlowSequenceEntry(true);
+                    return produceCommentEvent((CommentToken) scanner.getToken());
                 } else if (!scanner.checkToken(Token.ID.FlowSequenceEnd)) {
                     states.push(new ParseFlowSequenceEntry(false));
                     return parseFlowNode();
@@ -805,7 +812,9 @@ public class ParserImpl implements Parser {
 
     private class ParseFlowSequenceEntryMappingValue implements Production {
         public Event produce() {
-            if (scanner.checkToken(Token.ID.Value)) {
+            if (scanner.checkToken(Token.ID.Comment)) {
+                return produceCommentEvent((CommentToken) scanner.getToken());
+            } else if (scanner.checkToken(Token.ID.Value)) {
                 Token token = scanner.getToken();
                 if (!scanner.checkToken(Token.ID.FlowEntry, Token.ID.FlowSequenceEnd)) {
                     states.push(new ParseFlowSequenceEntryMappingEnd());
@@ -841,6 +850,9 @@ public class ParserImpl implements Parser {
      */
     private class ParseFlowMappingFirstKey implements Production {
         public Event produce() {
+            if (scanner.checkToken(Token.ID.Comment)) {
+                return produceCommentEvent((CommentToken) scanner.getToken());
+            }
             Token token = scanner.getToken();
             marks.push(token.getStartMark());
             return new ParseFlowMappingKey(true).produce();
@@ -848,15 +860,15 @@ public class ParserImpl implements Parser {
     }
 
     private class ParseFlowMappingKey implements Production {
-        private boolean first = false;
+        private boolean entryTokenSeen = false;
 
-        public ParseFlowMappingKey(boolean first) {
-            this.first = first;
+        public ParseFlowMappingKey(boolean entryTokenSeen) {
+            this.entryTokenSeen = entryTokenSeen;
         }
 
         public Event produce() {
             if (!scanner.checkToken(Token.ID.FlowMappingEnd)) {
-                if (!first) {
+                if (!entryTokenSeen) {
                     if (scanner.checkToken(Token.ID.FlowEntry)) {
                         scanner.getToken();
                     } else {
@@ -876,6 +888,9 @@ public class ParserImpl implements Parser {
                         state = new ParseFlowMappingValue();
                         return processEmptyScalar(token.getEndMark());
                     }
+                } else if (scanner.checkToken(Token.ID.Comment)) {
+                    state = new ParseFlowMappingKey(true);
+                    return produceCommentEvent((CommentToken) scanner.getToken());
                 } else if (!scanner.checkToken(Token.ID.FlowMappingEnd)) {
                     states.push(new ParseFlowMappingEmptyValue());
                     return parseFlowNode();
@@ -895,7 +910,9 @@ public class ParserImpl implements Parser {
 
     private class ParseFlowMappingValue implements Production {
         public Event produce() {
-            if (scanner.checkToken(Token.ID.Value)) {
+            if (scanner.checkToken(Token.ID.Comment)) {
+                return produceCommentEvent((CommentToken) scanner.getToken());
+            } else if (scanner.checkToken(Token.ID.Value)) {
                 Token token = scanner.getToken();
                 if (!scanner.checkToken(Token.ID.FlowEntry, Token.ID.FlowMappingEnd)) {
                     states.push(new ParseFlowMappingKey(false));
diff --git a/src/test/java/org/yaml/snakeyaml/comment/ParserWithCommentEnabledTest.java b/src/test/java/org/yaml/snakeyaml/comment/ParserWithCommentEnabledTest.java
index eccc9bbce38ffa5ea9d791da90dded8dcce8c562..b0b91977a769b68e0f28f203852c5a9705cebc33 100644
--- a/src/test/java/org/yaml/snakeyaml/comment/ParserWithCommentEnabledTest.java
+++ b/src/test/java/org/yaml/snakeyaml/comment/ParserWithCommentEnabledTest.java
@@ -21,6 +21,9 @@ import org.yaml.snakeyaml.events.Event.ID;
 import org.yaml.snakeyaml.parser.Parser;
 import org.yaml.snakeyaml.parser.ParserImpl;
 import org.yaml.snakeyaml.reader.StreamReader;
+import org.yaml.snakeyaml.scanner.Scanner;
+import org.yaml.snakeyaml.scanner.ScannerImpl;
+import org.yaml.snakeyaml.tokens.Token;
 
 import java.util.Arrays;
 import java.util.List;
@@ -29,7 +32,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public class ParserWithCommentEnabledTest {
-    private boolean DEBUG = false;
+    private boolean DEBUG = true;
 
     private void println(String s) {
         if (DEBUG) System.out.println(s);
@@ -380,7 +383,7 @@ public class ParserWithCommentEnabledTest {
 //        printEventList(sut);
         assertEventListEquals(expectedEventIdList, sut);
     }
-    
+
     @Test
     public void testKeepingNewLineInsideSequence() throws Exception {
         String data = "" +
@@ -431,4 +434,103 @@ public class ParserWithCommentEnabledTest {
 
     }
 
+    @Test
+    public void testInlineCommentsInBlockSequence() throws Exception {
+        String data = "" +
+                "core:\n" +
+                "  users:\n" +
+                "    # comment on list entry\n" +
+                "    - # ambiguous comment\n" +
+                "      first: one\n" +
+                "      # another one\n" +
+                "      second: two\n" +
+                "";
+
+        List<ID> expectedEvents = Arrays.asList(
+                ID.StreamStart,
+                ID.DocumentStart,
+                ID.MappingStart,
+                ID.Scalar, ID.MappingStart,
+                ID.Scalar,
+                ID.Comment,
+                ID.SequenceStart,
+                ID.Comment,
+                ID.MappingStart,
+                ID.Scalar, ID.Scalar,
+                ID.Comment,
+                ID.Scalar, ID.Scalar,
+                ID.MappingEnd,
+                ID.SequenceEnd,
+                ID.MappingEnd,
+                ID.MappingEnd,
+                ID.DocumentEnd,
+                ID.StreamEnd
+        );
+
+        final Parser parser = createParser(data);
+        assertEventListEquals(expectedEvents, parser);
+    }
+
+    @Test
+    public void testCommentsInFlowSequence() {
+        String data = "" +
+            "# Beginning\n" +
+            "[\n" +
+            "    # Hello\n" +
+            "    first item,\n" +
+            "    # World\n" +
+            "    second item\n" +
+            "]\n";
+
+        List<ID> expectedEvents = Arrays.asList(
+            ID.StreamStart,
+            ID.Comment,
+            ID.DocumentStart,
+            ID.SequenceStart,
+            ID.Comment,
+            ID.Scalar,
+            ID.Comment,
+            ID.Scalar,
+            ID.SequenceEnd,
+            ID.DocumentEnd,
+            ID.StreamEnd
+        );
+
+        final Parser parser = createParser(data);
+        assertEventListEquals(expectedEvents, parser);
+    }
+
+    @Test
+    public void testCommentsInFlowMapping() {
+        String data = "" +
+            "# Beginning\n" +
+            "{\n" +
+            "    # Hello\n" +
+            "    key1: meow,\n" +
+            "    # World\n" +
+            "    key2: purr\n" +
+            "}\n";
+
+        List<ID> expectedEvents = Arrays.asList(
+            ID.StreamStart,
+            ID.Comment,
+            ID.DocumentStart,
+            ID.MappingStart,
+            ID.Comment,
+            ID.Scalar, ID.Scalar,
+            ID.Comment,
+            ID.Scalar, ID.Scalar,
+            ID.MappingEnd,
+            ID.DocumentEnd,
+            ID.StreamEnd
+        );
+
+        final Scanner scanner = new ScannerImpl(new StreamReader(data)).setEmitComments(true);
+        do {
+            System.out.println(scanner.getToken().getTokenId().name());
+        } while (!scanner.checkToken(Token.ID.StreamEnd));
+
+        final Parser parser = createParser(data);
+        assertEventListEquals(expectedEvents, parser);
+    }
 }
